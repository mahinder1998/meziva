/**
 * A bounded array that automatically maintains a maximum size by removing
 * the oldest entries when new items are added beyond the limit.
 *
 * Extends the native Array class to provide all standard array methods
 * while enforcing a fixed maximum size of MAX_ARRAY_SIZE (1000 entries).
 *
 * When the size limit is exceeded, the oldest entries (at the beginning
 * of the array) are automatically removed to make room for new ones.
 *
 * @example
 *   const commands = new BArray()
 *   commands.push(entry) // Automatically removes oldest if over 1000
 */
export declare class BArray<T> extends Array<T> {
    push(...items: T[]): number;
    clear(): void;
    toArray(): T[];
    private enforceLimit;
}
/**
 * A bounded map that automatically maintains a maximum number of keys by
 * removing the oldest entries when new keys are added beyond the limit.
 *
 * Extends the native Map class to provide all standard map methods while
 * enforcing a fixed maximum size of MAX_MAP_KEYS (1000 entries).
 *
 * Tracks insertion order to ensure the oldest keys are removed first when
 * the limit is exceeded. This provides LRU-like behavior based on insertion
 * time rather than access time.
 *
 * @example
 *   const events = new BMap()
 *   events.set('event', 1) // Automatically removes oldest if over 1000
 */
export declare class BMap<TKey, TValue> extends Map<TKey, TValue> {
    private insertionOrder;
    set(key: TKey, value: TValue): this;
    delete(key: TKey): boolean;
    clear(): void;
    toObject(): {
        [key: string]: TValue;
    };
    private enforceLimit;
}
