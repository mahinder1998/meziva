{"version":3,"file":"sleep-with-backoff.js","sourceRoot":"","sources":["../../../src/private/node/sleep-with-backoff.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,KAAK,EAAC,MAAM,6BAA6B,CAAA;AAEjD,MAAM,sBAAsB,GAAG,GAAG,CAAA;AAClC,qBAAqB;AACrB,MAAM,CAAC,MAAM,mBAAmB,GAAG,KAAK,CAAA;AAOxC;;;;;;GAMG;AACH,SAAS,qBAAqB,CAC5B,OAAe,EACf,YAAoB,EACpB,iBAAyB,mBAAmB,GAAG,CAAC;IAEhD,IAAI,OAAO,KAAK,CAAC,EAAE,CAAC;QAClB,OAAO,CAAC,CAAA;IACV,CAAC;IACD,MAAM,eAAe,GAAG,CAAC,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,CAAA;IAC1C,OAAO,IAAI,CAAC,GAAG,CAAC,YAAY,GAAG,eAAe,EAAE,cAAc,CAAC,CAAA;AACjE,CAAC;AAED;;GAEG;AACH,KAAK,SAAS,CAAC,CAAC,gBAAgB,CAC9B,cAA8C,EAC9C,YAAoB;IAEpB,IAAI,OAAO,GAAG,CAAC,CAAA;IAEf,OAAO,IAAI,EAAE,CAAC;QACZ,MAAM,WAAW,GAAG,qBAAqB,CAAC,OAAO,EAAE,YAAY,CAAC,CAAA;QAChE,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,EAAE,CAAC;YACjC,OAAO,EAAC,WAAW,EAAE,CAAC,EAAE,UAAU,EAAE,OAAO,EAAC,CAAA;QAC9C,CAAC;QAED,4CAA4C;QAC5C,MAAM,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC,CAAA;QAC/B,MAAM,WAAW,CAAA;QACjB,OAAO,EAAE,CAAA;IACX,CAAC;AACH,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,CAAC,KAAK,SAAS,CAAC,CAAC,qBAAqB,CAC1C,YAAoB,mBAAmB,EACvC,eAAuB,sBAAsB;IAE7C,IAAI,SAAS,IAAI,CAAC,EAAE,CAAC;QACnB,OAAO,EAAC,WAAW,EAAE,CAAC,EAAE,UAAU,EAAE,CAAC,EAAC,CAAA;IACxC,CAAC;IAED,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;IAC5B,MAAM,SAAS,GAAG,gBAAgB,CAAC,CAAC,SAAS,EAAE,EAAE;QAC/C,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAA;QAC1C,OAAO,WAAW,GAAG,SAAS,IAAI,SAAS,CAAA;IAC7C,CAAC,EAAE,YAAY,CAAC,CAAA;IAEhB,IAAI,OAAO,GAAG,CAAC,CAAA;IACf,IAAI,KAAK,EAAE,MAAM,OAAO,IAAI,SAAS,EAAE,CAAC;QACtC,MAAM,OAAO,CAAA;QACb,OAAO,EAAE,CAAA;IACX,CAAC;IAED,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAA;IAC1C,OAAO;QACL,WAAW,EAAE,SAAS,GAAG,WAAW;QACpC,UAAU,EAAE,OAAO;KACpB,CAAA;AACH,CAAC","sourcesContent":["import {sleep} from '../../public/node/system.js'\n\nconst DEFAULT_RETRY_DELAY_MS = 300\n// 10 seconds default\nexport const DEFAULT_MAX_TIME_MS = 10000\n\ninterface BackoffResult {\n  remainingMs: number\n  iterations: number\n}\n\n/**\n * Calculates the delay for a given attempt in exponential backoff\n *\n * First result is zero, second result is firstDelayMs, third result is firstDelay * 2, then * 4, then * 8, etc.\n *\n * Delays are capped by a maximum value.\n */\nfunction calculateBackoffDelay(\n  attempt: number,\n  firstDelayMs: number,\n  maximumDelayMs: number = DEFAULT_MAX_TIME_MS / 3,\n): number {\n  if (attempt === 0) {\n    return 0\n  }\n  const delayMultiplier = 2 ** (attempt - 1)\n  return Math.min(firstDelayMs * delayMultiplier, maximumDelayMs)\n}\n\n/**\n * Common generator function for backoff implementations\n */\nasync function* backoffGenerator(\n  shouldContinue: (nextDelay: number) => boolean,\n  firstDelayMs: number,\n): AsyncGenerator<number, BackoffResult, unknown> {\n  let attempt = 0\n\n  while (true) {\n    const nextDelayMs = calculateBackoffDelay(attempt, firstDelayMs)\n    if (!shouldContinue(nextDelayMs)) {\n      return {remainingMs: 0, iterations: attempt}\n    }\n\n    // eslint-disable-next-line no-await-in-loop\n    await sleep(nextDelayMs / 1000)\n    yield nextDelayMs\n    attempt++\n  }\n}\n\n/**\n * Generator that sleeps with exponential backoff between yields, stopping before exceeding a time limit\n *\n * Yields the amount of time slept in milliseconds.\n *\n * @param maxTimeMs - Maximum total time in milliseconds before stopping\n * @param firstDelayMs - First delay in milliseconds\n * @returns Information about the backoff sequence: remaining time and iteration count\n */\nexport async function* sleepWithBackoffUntil(\n  maxTimeMs: number = DEFAULT_MAX_TIME_MS,\n  firstDelayMs: number = DEFAULT_RETRY_DELAY_MS,\n): AsyncGenerator<number, BackoffResult, unknown> {\n  if (maxTimeMs <= 0) {\n    return {remainingMs: 0, iterations: 0}\n  }\n\n  const startTime = Date.now()\n  const generator = backoffGenerator((nextDelay) => {\n    const elapsedTime = Date.now() - startTime\n    return elapsedTime + nextDelay <= maxTimeMs\n  }, firstDelayMs)\n\n  let attempt = 0\n  for await (const delayMs of generator) {\n    yield delayMs\n    attempt++\n  }\n\n  const elapsedTime = Date.now() - startTime\n  return {\n    remainingMs: maxTimeMs - elapsedTime,\n    iterations: attempt,\n  }\n}\n"]}