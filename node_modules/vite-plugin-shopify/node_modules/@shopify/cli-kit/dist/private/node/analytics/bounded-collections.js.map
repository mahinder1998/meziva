{"version":3,"file":"bounded-collections.js","sourceRoot":"","sources":["../../../../src/private/node/analytics/bounded-collections.ts"],"names":[],"mappings":"AAAA;;GAEG;AACH,MAAM,cAAc,GAAG,IAAI,CAAA;AAE3B;;GAEG;AACH,MAAM,YAAY,GAAG,IAAI,CAAA;AAEzB;;;;;;;;;;;;;GAaG;AACH,MAAM,OAAO,MAAU,SAAQ,KAAQ;IACrC,IAAI,CAAC,GAAG,KAAU;QAChB,MAAM,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAA;QACnC,IAAI,CAAC,YAAY,EAAE,CAAA;QACnB,OAAO,MAAM,CAAA;IACf,CAAC;IAED,KAAK;QACH,IAAI,CAAC,MAAM,GAAG,CAAC,CAAA;IACjB,CAAC;IAED,OAAO;QACL,OAAO,CAAC,GAAG,IAAI,CAAC,CAAA;IAClB,CAAC;IAEO,YAAY;QAClB,OAAO,IAAI,CAAC,MAAM,GAAG,cAAc,EAAE,CAAC;YACpC,IAAI,CAAC,KAAK,EAAE,CAAA;QACd,CAAC;IACH,CAAC;CACF;AAED;;;;;;;;;;;;;;GAcG;AACH,MAAM,OAAO,IAAmB,SAAQ,GAAiB;IAAzD;;QACU,mBAAc,GAAW,EAAE,CAAA;IAoCrC,CAAC;IAlCC,GAAG,CAAC,GAAS,EAAE,KAAa;QAC1B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACnB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QAC/B,CAAC;QACD,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QACrB,IAAI,CAAC,YAAY,EAAE,CAAA;QACnB,OAAO,IAAI,CAAA;IACb,CAAC;IAED,MAAM,CAAC,GAAS;QACd,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;QAC9C,IAAI,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC;YACf,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAA;QACtC,CAAC;QACD,OAAO,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;IAC1B,CAAC;IAED,KAAK;QACH,IAAI,CAAC,cAAc,GAAG,EAAE,CAAA;QACxB,KAAK,CAAC,KAAK,EAAE,CAAA;IACf,CAAC;IAED,QAAQ;QACN,OAAO,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAA;IACjC,CAAC;IAEO,YAAY;QAClB,OAAO,IAAI,CAAC,IAAI,GAAG,YAAY,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAClE,MAAM,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAA;YAC7C,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;gBAC5B,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;YACzB,CAAC;QACH,CAAC;IACH,CAAC;CACF","sourcesContent":["/**\n * Ensures bounded arrays stay within reasonable memory limits.\n */\nconst MAX_ARRAY_SIZE = 1000\n\n/**\n * Estimated ~500KB total across timing, error, retry, and event entries.\n */\nconst MAX_MAP_KEYS = 1000\n\n/**\n * A bounded array that automatically maintains a maximum size by removing\n * the oldest entries when new items are added beyond the limit.\n *\n * Extends the native Array class to provide all standard array methods\n * while enforcing a fixed maximum size of MAX_ARRAY_SIZE (1000 entries).\n *\n * When the size limit is exceeded, the oldest entries (at the beginning\n * of the array) are automatically removed to make room for new ones.\n *\n * @example\n *   const commands = new BArray()\n *   commands.push(entry) // Automatically removes oldest if over 1000\n */\nexport class BArray<T> extends Array<T> {\n  push(...items: T[]): number {\n    const result = super.push(...items)\n    this.enforceLimit()\n    return result\n  }\n\n  clear(): void {\n    this.length = 0\n  }\n\n  toArray(): T[] {\n    return [...this]\n  }\n\n  private enforceLimit(): void {\n    while (this.length > MAX_ARRAY_SIZE) {\n      this.shift()\n    }\n  }\n}\n\n/**\n * A bounded map that automatically maintains a maximum number of keys by\n * removing the oldest entries when new keys are added beyond the limit.\n *\n * Extends the native Map class to provide all standard map methods while\n * enforcing a fixed maximum size of MAX_MAP_KEYS (1000 entries).\n *\n * Tracks insertion order to ensure the oldest keys are removed first when\n * the limit is exceeded. This provides LRU-like behavior based on insertion\n * time rather than access time.\n *\n * @example\n *   const events = new BMap()\n *   events.set('event', 1) // Automatically removes oldest if over 1000\n */\nexport class BMap<TKey, TValue> extends Map<TKey, TValue> {\n  private insertionOrder: TKey[] = []\n\n  set(key: TKey, value: TValue): this {\n    if (!this.has(key)) {\n      this.insertionOrder.push(key)\n    }\n    super.set(key, value)\n    this.enforceLimit()\n    return this\n  }\n\n  delete(key: TKey): boolean {\n    const index = this.insertionOrder.indexOf(key)\n    if (index > -1) {\n      this.insertionOrder.splice(index, 1)\n    }\n    return super.delete(key)\n  }\n\n  clear(): void {\n    this.insertionOrder = []\n    super.clear()\n  }\n\n  toObject(): {[key: string]: TValue} {\n    return Object.fromEntries(this)\n  }\n\n  private enforceLimit(): void {\n    while (this.size > MAX_MAP_KEYS && this.insertionOrder.length > 0) {\n      const oldestKey = this.insertionOrder.shift()\n      if (oldestKey !== undefined) {\n        super.delete(oldestKey)\n      }\n    }\n  }\n}\n"]}