{"version":3,"file":"git.js","sourceRoot":"","sources":["../../../src/public/node/git.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-base-to-string */\nimport {hasGit, isTerminalInteractive} from './context/local.js'\nimport {\n  appendFileSync,\n  detectEOL,\n  fileExists,\n  fileExistsSync,\n  glob,\n  isDirectory,\n  readFileSync,\n  writeFileSync,\n} from './fs.js'\nimport {AbortError} from './error.js'\nimport {cwd, joinPath} from './path.js'\nimport {runWithTimer} from './metadata.js'\nimport {outputContent, outputToken, outputDebug} from '../../public/node/output.js'\nimport git, {TaskOptions, SimpleGitProgressEvent, DefaultLogFields, ListLogLine, SimpleGit} from 'simple-git'\nimport ignore from 'ignore'\n\n/**\n * Initialize a git repository at the given directory.\n *\n * @param directory - The directory where the git repository will be initialized.\n * @param initialBranch - The name of the initial branch.\n */\nexport async function initializeGitRepository(directory: string, initialBranch = 'main'): Promise<void> {\n  outputDebug(outputContent`Initializing git repository at ${outputToken.path(directory)}...`)\n  await ensureGitIsPresentOrAbort()\n  // We use init and checkout instead of `init --initial-branch` because the latter is only supported in git 2.28+\n  await withGit({directory}, async (repo) => {\n    await repo.init()\n    await repo.checkoutLocalBranch(initialBranch)\n  })\n}\n\n/**\n * Given a Git repository and a list of absolute paths to files contained\n * in the repository, it filters and returns the files that are ignored\n * by the .gitignore.\n *\n * @param directory - The absolute path to the directory containing the files.\n * @param files - The list of files to check against.\n * @returns Files ignored by the lockfile.\n */\nexport async function checkIfIgnoredInGitRepository(directory: string, files: string[]): Promise<string[]> {\n  return withGit({directory}, (repo) => repo.checkIgnore(files))\n}\n\nexport interface GitIgnoreTemplate {\n  [section: string]: string[]\n}\n/**\n * Create a .gitignore file in the given directory.\n *\n * @param directory - The directory where the .gitignore file will be created.\n * @param template - The template to use to create the .gitignore file.\n */\nexport function createGitIgnore(directory: string, template: GitIgnoreTemplate): void {\n  outputDebug(outputContent`Creating .gitignore at ${outputToken.path(directory)}...`)\n  const filePath = `${directory}/.gitignore`\n\n  let fileContent = ''\n  for (const [section, lines] of Object.entries(template)) {\n    fileContent += `# ${section}\\n`\n    fileContent += `${lines.join('\\n')}\\n\\n`\n  }\n\n  appendFileSync(filePath, fileContent)\n}\n\n/**\n * Add an entry to an existing .gitignore file.\n *\n * If the .gitignore file doesn't exist, or if the entry is already present,\n * no changes will be made.\n *\n * @param root - The directory containing the .gitignore file.\n * @param entry - The entry to add to the .gitignore file.\n */\nexport function addToGitIgnore(root: string, entry: string): void {\n  const gitIgnorePath = joinPath(root, '.gitignore')\n\n  if (!fileExistsSync(gitIgnorePath)) {\n    // When the .gitignore file does not exist, the CLI should not be opinionated about creating it\n    return\n  }\n\n  const gitIgnoreContent = readFileSync(gitIgnorePath).toString()\n  const eol = detectEOL(gitIgnoreContent)\n\n  const lines = gitIgnoreContent.split(eol).map((line) => line.trim())\n  const ignoreManager = ignore.default({allowRelativePaths: true}).add(lines)\n\n  const isIgnoredEntry = ignoreManager.ignores(joinPath(entry))\n  const isIgnoredEntryAsDir = ignoreManager.ignores(joinPath(entry, 'ignored.txt'))\n  const isAlreadyIgnored = isIgnoredEntry || isIgnoredEntryAsDir\n  if (isAlreadyIgnored) {\n    // The file is already ignored by an existing pattern\n    return\n  }\n\n  if (gitIgnoreContent.endsWith(eol)) {\n    writeFileSync(gitIgnorePath, `${gitIgnoreContent}${entry}${eol}`)\n  } else {\n    writeFileSync(gitIgnorePath, `${gitIgnoreContent}${eol}${entry}${eol}`)\n  }\n}\n\n/**\n * Options to use when cloning a git repository.\n *\n * @param repoUrl - The URL of the repository to clone.\n * @param destination - The directory where the repository will be cloned.\n * @param progressUpdater - A function that will be called with the progress of the clone.\n * @param shallow - Whether to clone the repository shallowly.\n * @param latestTag - Whether to clone the latest tag instead of the default branch.\n */\nexport interface GitCloneOptions {\n  repoUrl: string\n  destination: string\n  progressUpdater?: (statusString: string) => void\n  shallow?: boolean\n  latestTag?: boolean\n}\n/**\n * Clone a git repository.\n *\n * @param cloneOptions - The options to use to clone the repository.\n * @returns A promise that resolves when the clone is complete.\n */\nexport async function downloadGitRepository(cloneOptions: GitCloneOptions): Promise<void> {\n  return runWithTimer('cmd_all_timing_network_ms')(async () => {\n    const {repoUrl, destination, progressUpdater, shallow, latestTag} = cloneOptions\n    outputDebug(outputContent`Git-cloning repository ${repoUrl} into ${outputToken.path(destination)}...`)\n    await ensureGitIsPresentOrAbort()\n\n    // Validate destination directory before attempting to clone\n    if (await fileExists(destination)) {\n      // Check if it's a directory\n      if (!(await isDirectory(destination))) {\n        throw new AbortError(\n          outputContent`Can't clone to ${outputToken.path(destination)}`,\n          \"The path exists but isn't a directory.\",\n        )\n      }\n\n      // Check if directory is empty\n      const entries = await glob(['*', '.*'], {\n        cwd: destination,\n        deep: 1,\n        onlyFiles: false,\n      })\n\n      if (entries.length > 0) {\n        throw new AbortError(\n          outputContent`Directory ${outputToken.path(destination)} already exists and is not empty`,\n          outputContent`Choose a different name or remove the existing directory first.`,\n        )\n      }\n    }\n\n    const [repository, branch] = repoUrl.split('#')\n    const options: TaskOptions = {'--recurse-submodules': null}\n\n    if (branch && latestTag) {\n      throw new AbortError(\"Error cloning the repository. Git can't clone the latest release with a 'branch'.\")\n    }\n    if (branch) {\n      options['--branch'] = branch\n    }\n\n    if (shallow && latestTag) {\n      throw new AbortError(\n        \"Error cloning the repository. Git can't clone the latest release with the 'shallow' property.\",\n      )\n    }\n    if (shallow) {\n      options['--depth'] = 1\n    }\n\n    const progress = ({stage, progress, processed, total}: SimpleGitProgressEvent) => {\n      const updateString = `${stage}, ${processed}/${total} objects (${progress}% complete)`\n      if (progressUpdater) progressUpdater(updateString)\n    }\n\n    const simpleGitOptions = {\n      progress,\n      ...(!isTerminalInteractive() && {config: ['core.askpass=true']}),\n    }\n    try {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      await git(simpleGitOptions).clone(repository!, destination, options)\n\n      if (latestTag) {\n        await withGit({directory: destination}, async (localGitRepository) => {\n          const latestTag = await getLocalLatestTag(localGitRepository, repoUrl)\n          await localGitRepository.checkout(latestTag)\n        })\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        const abortError = new AbortError(err.message)\n        abortError.stack = err.stack\n        throw abortError\n      }\n      throw err\n    }\n  })\n}\n\n/**\n * Get the most recent tag of a local git repository.\n *\n * @param repository - The local git repository.\n * @param repoUrl - The URL of the repository.\n * @returns The most recent tag of the repository.\n */\nasync function getLocalLatestTag(repository: SimpleGit, repoUrl: string): Promise<string> {\n  const latest = (await repository.tags()).latest\n\n  if (!latest) {\n    throw new AbortError(`Couldn't obtain the most recent tag of the repository ${repoUrl}`)\n  }\n\n  return latest\n}\n\n/**\n * Get the latest commit of a git repository.\n *\n * @param directory - The directory of the git repository.\n * @returns The latest commit of the repository.\n */\nexport async function getLatestGitCommit(directory?: string): Promise<DefaultLogFields & ListLogLine> {\n  const logs = await withGit({directory}, (repo) => repo.log({maxCount: 1}))\n  if (!logs.latest) {\n    throw new AbortError(\n      'Must have at least one commit to run command',\n      outputContent`Run ${outputToken.genericShellCommand(\n        \"git commit -m 'Initial commit'\",\n      )} to create your first commit.`,\n    )\n  }\n  return logs.latest\n}\n\n/**\n * Add all files to the git index from the given directory.\n *\n * @param directory - The directory where the git repository is located.\n * @returns A promise that resolves when the files are added to the index.\n */\nexport async function addAllToGitFromDirectory(directory?: string): Promise<void> {\n  await withGit({directory}, (repo) => repo.raw('add', '--all'))\n}\n\nexport interface CreateGitCommitOptions {\n  directory?: string\n  author?: string\n}\n\n/**\n * Create a git commit.\n *\n * @param message - The message of the commit.\n * @param options - The options to use to create the commit.\n * @returns The hash of the created commit.\n */\nexport async function createGitCommit(message: string, options?: CreateGitCommitOptions): Promise<string> {\n  const commitOptions = options?.author ? {'--author': options.author} : undefined\n  const result = await withGit({directory: options?.directory}, (repo) => repo.commit(message, commitOptions))\n  return result.commit\n}\n\n/**\n * Get the HEAD symbolic reference of a git repository.\n *\n * @param directory - The directory of the git repository.\n * @returns The HEAD symbolic reference of the repository.\n */\nexport async function getHeadSymbolicRef(directory?: string): Promise<string> {\n  const ref = await withGit({directory}, (repo) => repo.raw('symbolic-ref', '-q', 'HEAD'))\n  if (!ref) {\n    throw new AbortError(\n      \"Git HEAD can't be detached to run command\",\n      outputContent`Run ${outputToken.genericShellCommand(\n        'git checkout [branchName]',\n      )} to reattach HEAD or see git ${outputToken.link(\n        'documentation',\n        'https://git-scm.com/book/en/v2/Git-Internals-Git-References',\n      )} for more details`,\n    )\n  }\n  return ref.trim()\n}\n\n/**\n * If \"git\" is not present in the environment it throws\n * an abort error.\n */\nexport async function ensureGitIsPresentOrAbort(): Promise<void> {\n  if (!(await hasGit())) {\n    throw new AbortError(\n      `Git is necessary in the environment to continue`,\n      outputContent`Install ${outputToken.link(\n        'git',\n        'https://git-scm.com/book/en/v2/Getting-Started-Installing-Git',\n      )}`,\n    )\n  }\n}\n\nexport class OutsideGitDirectoryError extends AbortError {}\n/**\n * If command run from outside a .git directory tree\n * it throws an abort error.\n *\n * @param directory - The directory to check.\n */\nexport async function ensureInsideGitDirectory(directory?: string): Promise<void> {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  if (!(await insideGitDirectory(directory))) {\n    throw new OutsideGitDirectoryError(`${outputToken.path(directory || cwd())} is not a Git directory`)\n  }\n}\n\n/**\n * Returns true if the given directory is inside a .git directory tree.\n *\n * @param directory - The directory to check.\n * @returns True if the directory is inside a .git directory tree.\n */\nexport async function insideGitDirectory(directory?: string): Promise<boolean> {\n  return withGit({directory}, (repo) => repo.checkIsRepo())\n}\n\nexport class GitDirectoryNotCleanError extends AbortError {}\n/**\n * If the .git directory tree is not clean (has uncommitted changes)\n * it throws an abort error.\n *\n * @param directory - The directory to check.\n */\nexport async function ensureIsClean(directory?: string): Promise<void> {\n  if (!(await isClean(directory))) {\n    throw new GitDirectoryNotCleanError(`${outputToken.path(directory || cwd())} is not a clean Git directory`)\n  }\n}\n\n/**\n * Returns true if the .git directory tree is clean (no uncommitted changes).\n *\n * @param directory - The directory to check.\n * @returns True is the .git directory is clean.\n */\nexport async function isClean(directory?: string): Promise<boolean> {\n  return (await withGit({directory}, (git: SimpleGit) => git.status())).isClean()\n}\n\n/**\n * Returns the latest tag of a git repository.\n *\n * @param directory - The directory to check.\n * @returns String with the latest tag or undefined if no tags are found.\n */\nexport async function getLatestTag(directory?: string): Promise<string | undefined> {\n  const tags = await withGit({directory}, (repo) => repo.tags())\n  return tags.latest\n}\n\n/**\n * Remove a git remote from the given directory.\n *\n * @param directory - The directory where the git repository is located.\n * @param remoteName - The name of the remote to remove (defaults to 'origin').\n * @returns A promise that resolves when the remote is removed.\n */\nexport async function removeGitRemote(directory: string, remoteName = 'origin'): Promise<void> {\n  outputDebug(outputContent`Removing git remote ${remoteName} from ${outputToken.path(directory)}...`)\n  await ensureGitIsPresentOrAbort()\n\n  await withGit({directory}, async (repo) => {\n    // Check if remote exists first\n    const remotes = await repo.getRemotes()\n    const remoteExists = remotes.some((remote: {name: string}) => remote.name === remoteName)\n\n    if (!remoteExists) {\n      outputDebug(outputContent`Remote ${remoteName} does not exist, no action needed`)\n      return\n    }\n\n    await repo.removeRemote(remoteName)\n  })\n}\n\nasync function withGit<T>(\n  {\n    directory,\n  }: {\n    directory?: string\n  },\n  callback: (git: SimpleGit) => Promise<T>,\n): Promise<T> {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const repo = git({baseDir: directory})\n  try {\n    return await callback(repo)\n  } catch (err) {\n    if (err instanceof Error) {\n      const abortError = new AbortError(err.message)\n      abortError.stack = err.stack\n      throw abortError\n    }\n    throw err\n  }\n}\n"]}