{"version":3,"file":"archiver.js","sourceRoot":"","sources":["../../../src/public/node/archiver.ts"],"names":[],"mappings":"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","sourcesContent":["import {relativePath, joinPath, dirname} from './path.js'\nimport {glob, removeFile} from './fs.js'\nimport {outputDebug, outputContent, outputToken} from '../../public/node/output.js'\nimport archiver from 'archiver'\nimport {createWriteStream, readFileSync, writeFileSync} from 'fs'\nimport {readFile} from 'fs/promises'\nimport {tmpdir} from 'os'\nimport {randomUUID} from 'crypto'\n\ninterface ZipOptions {\n  /**\n   * The absolute path to the directory to be zipped.\n   */\n  inputDirectory: string\n\n  /**\n   * The absolute path to the output zip file.\n   */\n  outputZipPath: string\n\n  /**\n   * Pattern(s) to match when adding files to zip, uses glob expressions.\n   */\n  matchFilePattern?: string | string[]\n}\n\n/**\n * It zips a directory and by default normalizes the paths to be forward-slash.\n * Even with forward-slash paths, zip files should still be able to be opened on\n * Windows.\n *\n * @param options - ZipOptions.\n */\nexport async function zip(options: ZipOptions): Promise<void> {\n  const {inputDirectory, outputZipPath, matchFilePattern = '**/*'} = options\n  outputDebug(outputContent`Zipping ${outputToken.path(inputDirectory)} into ${outputToken.path(outputZipPath)}`)\n  const pathsToZip = await glob(matchFilePattern, {\n    cwd: inputDirectory,\n    absolute: true,\n    dot: true,\n    followSymbolicLinks: false,\n  })\n\n  return new Promise((resolve, reject) => {\n    const archive = archiver('zip')\n\n    const output = createWriteStream(outputZipPath)\n    output.on('close', () => {\n      resolve()\n    })\n    archive.on('error', (error) => {\n      reject(error)\n    })\n    archive.pipe(output)\n\n    const directoriesToAdd = new Set<string>()\n    for (const filePath of pathsToZip) {\n      const fileRelativePath = relativePath(inputDirectory, filePath)\n      collectParentDirectories(fileRelativePath, directoriesToAdd)\n    }\n\n    const sortedDirs = Array.from(directoriesToAdd).sort((left, right) => left.localeCompare(right))\n    for (const dir of sortedDirs) {\n      const dirName = dir.endsWith('/') ? dir : `${dir}/`\n      archive.append(Buffer.alloc(0), {name: dirName})\n    }\n\n    // Read all files immediately before adding to archive to prevent ENOENT errors\n    // Using archive.file() causes lazy loading which fails if files are deleted before finalize()\n    const addFilesPromises = pathsToZip.map(async (filePath) => {\n      await archiveFile(inputDirectory, filePath, archive)\n    })\n\n    // Wait for all files to be read and added before finalizing\n    Promise.all(addFilesPromises)\n      .then(() => {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        archive.finalize()\n      })\n      .catch((error) => {\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        reject(error)\n      })\n  })\n}\n\nfunction collectParentDirectories(fileRelativePath: string, accumulator: Set<string>): void {\n  let currentDir = dirname(fileRelativePath)\n  while (currentDir && currentDir !== '.' && currentDir !== '/') {\n    accumulator.add(currentDir)\n    const parent = dirname(currentDir)\n    if (parent === currentDir) break\n    currentDir = parent\n  }\n}\n\nasync function archiveFile(inputDirectory: string, filePath: string, archive: archiver.Archiver): Promise<void> {\n  const fileRelativePath = relativePath(inputDirectory, filePath)\n  if (!filePath || !fileRelativePath) return\n\n  // Read file content immediately to avoid race conditions\n  const fileContent = await readFile(filePath)\n  // Use append with Buffer instead of file() to avoid lazy file reading\n  archive.append(fileContent, {name: fileRelativePath})\n}\n\nexport interface BrotliOptions {\n  /**\n   * The directory to compress.\n   */\n  inputDirectory: string\n\n  /**\n   * The path where the compressed file will be saved.\n   */\n  outputPath: string\n\n  /**\n   * An optional glob pattern to match files.\n   */\n  matchFilePattern?: string | string[]\n\n  /**\n   * Brotli compression level (0-11, default: 11).\n   */\n  level?: number\n}\n\n/**\n * Options for decompressing a Brotli compressed tar archive.\n */\nexport interface DecompressionOptions {\n  /**\n   * Path to the compressed file.\n   */\n  inputFile: string\n\n  /**\n   * Directory where files should be extracted.\n   */\n  outputDirectory: string\n}\n\n/**\n * It compresses a directory with Brotli.\n * First creates a tar archive to preserve directory structure,\n * then compresses it with Brotli.\n *\n * @param options - BrotliOptions.\n */\nexport async function brotliCompress(options: BrotliOptions): Promise<void> {\n  const tempTarPath = joinPath(tmpdir(), `${randomUUID()}.tar`)\n\n  try {\n    // Create tar archive using archiver\n    await new Promise<void>((resolve, reject) => {\n      const archive = archiver('tar')\n      const output = createWriteStream(tempTarPath)\n\n      output.on('close', () => resolve())\n      archive.on('error', (error) => reject(error))\n      archive.pipe(output)\n\n      glob(options.matchFilePattern ?? '**/*', {\n        cwd: options.inputDirectory,\n        absolute: true,\n        dot: true,\n        followSymbolicLinks: false,\n      })\n        .then(async (pathsToZip) => {\n          // Read all files immediately to prevent ENOENT errors during race conditions\n          const addFilesPromises = pathsToZip.map(async (filePath) => {\n            await archiveFile(options.inputDirectory, filePath, archive)\n          })\n\n          await Promise.all(addFilesPromises)\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          archive.finalize()\n        })\n        .catch((error) => {\n          reject(error instanceof Error ? error : new Error(String(error)))\n        })\n    })\n\n    const tarContent = readFileSync(tempTarPath)\n    const brotli = await import('brotli')\n    const compressed = brotli.default.compress(tarContent, {\n      quality: 7,\n      mode: 0,\n    })\n\n    if (!compressed) {\n      throw new Error('Brotli compression failed')\n    }\n\n    writeFileSync(options.outputPath, compressed)\n  } finally {\n    try {\n      await removeFile(tempTarPath)\n      // eslint-disable-next-line no-catch-all/no-catch-all\n    } catch (error) {\n      outputDebug(outputContent`Failed to clean up temporary file: ${outputToken.path(tempTarPath)}`)\n    }\n  }\n}\n"]}