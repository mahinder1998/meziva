{"version":3,"file":"import-extractor.js","sourceRoot":"","sources":["../../../src/public/node/import-extractor.ts"],"names":[],"mappings":"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","sourcesContent":["import {readFileSync, fileExistsSync, isDirectorySync} from './fs.js'\nimport {dirname, joinPath} from './path.js'\n\n/**\n * Extracts import paths from a source file.\n * Supports JavaScript, TypeScript, and Rust files.\n *\n * @param filePath - Path to the file to analyze.\n * @returns Array of absolute paths to imported files.\n */\nexport function extractImportPaths(filePath: string): string[] {\n  const content = readFileSync(filePath).toString()\n  const ext = filePath.substring(filePath.lastIndexOf('.'))\n\n  switch (ext) {\n    case '.js':\n    case '.mjs':\n    case '.cjs':\n    case '.ts':\n    case '.tsx':\n    case '.jsx':\n      return extractJSLikeImports(content, filePath)\n    case '.rs':\n      return extractRustImports(content, filePath)\n    default:\n      return []\n  }\n}\n\n/**\n * Recursively extracts import paths from a source file and all its dependencies.\n * Supports JavaScript, TypeScript, and Rust files.\n * Handles circular dependencies by tracking visited files.\n *\n * @param filePath - Path to the file to analyze.\n * @param visited - Set of already visited files to prevent infinite recursion.\n * @returns Array of absolute paths to the provided file and all imported files there (including nested imports).\n * @throws If an unexpected error occurs while processing files (not including ENOENT file not found errors).\n */\nexport function extractImportPathsRecursively(filePath: string, visited: Set<string> = new Set<string>()): string[] {\n  // Avoid processing the same file twice (handles circular dependencies)\n  if (visited.has(filePath)) {\n    return []\n  }\n\n  visited.add(filePath)\n\n  // Get direct imports from this file\n  const directImports = extractImportPaths(filePath)\n  const allImports = [filePath, ...directImports]\n\n  // Recursively process each imported file\n  for (const importedFile of directImports) {\n    try {\n      // Only process files that exist and are not directories\n      // Note: resolveJSImport already resolves directory imports to their index files\n      if (fileExistsSync(importedFile) && !isDirectorySync(importedFile)) {\n        const nestedImports = extractImportPathsRecursively(importedFile, visited)\n        allImports.push(...nestedImports)\n      }\n    } catch (error) {\n      // Rethrow unexpected errors after checking for expected file read errors\n      if (error instanceof Error && error.message.includes('ENOENT')) {\n        // Skip files that don't exist or can't be read\n        continue\n      }\n      throw error\n    }\n  }\n\n  // Return unique list of imports\n  return [...new Set(allImports)]\n}\n\n/**\n * Extracts import paths from a JavaScript content.\n *\n * @param content - The content to extract imports from.\n * @param filePath - The path to the file to extract imports from.\n * @returns Array of absolute paths to imported files.\n */\nexport function extractJSImports(content: string, filePath: string): string[] {\n  return extractJSLikeImports(content, filePath)\n}\n\nfunction extractJSLikeImports(content: string, filePath: string): string[] {\n  const imports: string[] = []\n\n  // Regular expressions for different import types\n  const patterns = [\n    // ES6 imports: import ... from './path'\n    /import\\s+(?:[\\s\\S]*?)\\s+from\\s+['\"](\\.\\.?\\/[^'\"]+)['\"]/gm,\n    // ES6 side-effect imports: import './path'\n    /import\\s+['\"](\\.\\.?\\/[^'\"]+)['\"]/g,\n    // ES6 exports: export ... from './path'\n    /export\\s+(?:[\\s\\S]*?)\\s+from\\s+['\"](\\.\\.?\\/[^'\"]+)['\"]/gm,\n    // Dynamic imports: import('./path')\n    /import\\s*\\(\\s*['\"](\\.\\.?\\/[^'\"]+)['\"]\\s*\\)/g,\n    // CommonJS requires: require('./path')\n    /require\\s*\\(\\s*['\"](\\.\\.?\\/[^'\"]+)['\"]\\s*\\)/g,\n  ]\n\n  for (const pattern of patterns) {\n    let match\n    while ((match = pattern.exec(content)) !== null) {\n      const importPath = match[1]\n      if (importPath && importPath.startsWith('.')) {\n        const resolvedPath = resolveJSImport(importPath, filePath)\n        if (resolvedPath) {\n          imports.push(resolvedPath)\n        }\n      }\n    }\n  }\n\n  return [...new Set(imports)]\n}\n\nfunction extractRustImports(content: string, filePath: string): string[] {\n  const imports: string[] = []\n\n  // Basic Rust mod declarations: mod module_name;\n  const modPattern = /^\\s*(?:pub\\s+)?mod\\s+([a-z_][a-z0-9_]*)\\s*;/gm\n\n  let match\n  while ((match = modPattern.exec(content)) !== null) {\n    const modName = match[1]\n    if (modName) {\n      const modPath = resolveRustModule(modName, filePath)\n      if (modPath) {\n        imports.push(modPath)\n      }\n    }\n  }\n\n  // Handle #[path = \"...\"] attributes\n  const pathPattern = /#\\[path\\s*=\\s*\"([^\"]+)\"\\]/g\n  while ((match = pathPattern.exec(content)) !== null) {\n    const pathValue = match[1]\n    if (pathValue) {\n      const resolvedPath = joinPath(dirname(filePath), pathValue)\n      if (fileExistsSync(resolvedPath)) {\n        imports.push(resolvedPath)\n      }\n    }\n  }\n\n  return [...new Set(imports)]\n}\n\nfunction resolveJSImport(importPath: string, fromFile: string): string | null {\n  const basePath = fileExistsSync(fromFile) && isDirectorySync(fromFile) ? fromFile : dirname(fromFile)\n  const resolvedPath = joinPath(basePath, importPath)\n\n  // If the import path resolves to a directory, look for index files\n  if (fileExistsSync(resolvedPath) && isDirectorySync(resolvedPath)) {\n    const indexPaths = [\n      joinPath(resolvedPath, 'index.js'),\n      joinPath(resolvedPath, 'index.ts'),\n      joinPath(resolvedPath, 'index.tsx'),\n      joinPath(resolvedPath, 'index.jsx'),\n    ]\n\n    for (const indexPath of indexPaths) {\n      if (fileExistsSync(indexPath) && !isDirectorySync(indexPath)) {\n        return indexPath\n      }\n    }\n    // If no index file found, don't return the directory\n    return null\n  }\n\n  // Check for file with extensions\n  const possiblePaths = [\n    resolvedPath,\n    `${resolvedPath}.js`,\n    `${resolvedPath}.ts`,\n    `${resolvedPath}.tsx`,\n    `${resolvedPath}.jsx`,\n  ]\n\n  for (const path of possiblePaths) {\n    if (fileExistsSync(path) && !isDirectorySync(path)) {\n      return path\n    }\n  }\n\n  return null\n}\n\nfunction resolveRustModule(modName: string, fromFile: string): string | null {\n  const basePath = dirname(fromFile)\n  const possiblePaths = [joinPath(basePath, `${modName}.rs`), joinPath(basePath, modName, 'mod.rs')]\n\n  for (const path of possiblePaths) {\n    if (fileExistsSync(path)) {\n      return path\n    }\n  }\n\n  return null\n}\n"]}