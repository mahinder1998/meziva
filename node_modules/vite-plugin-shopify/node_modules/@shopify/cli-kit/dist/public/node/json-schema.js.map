{"version":3,"file":"json-schema.js","sourceRoot":"","sources":["../../../src/public/node/json-schema.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport {ParseConfigurationResult} from './schema.js'\nimport {randomUUID} from './crypto.js'\nimport {getPathValue} from '../common/object.js'\nimport {capitalize} from '../common/string.js'\nimport {Ajv, ErrorObject, SchemaObject, ValidateFunction} from 'ajv'\nimport $RefParser from '@apidevtools/json-schema-ref-parser'\nimport cloneDeep from 'lodash/cloneDeep.js'\n\nexport type HandleInvalidAdditionalProperties = 'strip' | 'fail'\n\ntype AjvError = ErrorObject<string, {[key: string]: unknown}>\n\n/**\n * Normalises a JSON Schema by standardising it's internal implementation.\n *\n * We prefer to not use $ref elements in our schemas, so we inline them; it's easier then to process errors.\n *\n * @param schema - The JSON schema (as a string) to normalise.\n * @returns The normalised JSON schema.\n */\nexport async function normaliseJsonSchema(schema: string): Promise<SchemaObject> {\n  // we want to modify the schema, removing any $ref elements and inlining with their source\n  const parsedSchema = JSON.parse(schema)\n  await $RefParser.dereference(parsedSchema, {resolve: {external: false}})\n  return parsedSchema\n}\n\nfunction createAjvValidator(\n  handleInvalidAdditionalProperties: HandleInvalidAdditionalProperties,\n  schema: SchemaObject,\n) {\n  // allowUnionTypes: Allows types like `type: [\"string\", \"number\"]`\n  if (handleInvalidAdditionalProperties === 'strip') {\n    // we need to let additional properties through, so that we can strip them later\n    schema.additionalProperties = true\n  }\n\n  const ajv = new Ajv({allowUnionTypes: true, allErrors: true, verbose: true})\n  ajv.addKeyword('x-taplo')\n\n  const validator = ajv.compile(schema)\n\n  return validator\n}\n\nconst validatorsCache = new Map<string, ValidateFunction>()\n\n/**\n * Given a subject object and a JSON schema contract, validate the subject against the contract.\n *\n * Errors are returned in a zod-like format, and processed to better handle unions.\n *\n * @param subject - The object to validate.\n * @param schema - The JSON schema to validate against.\n * @param handleInvalidAdditionalProperties - Whether to strip or fail on invalid additional properties.\n * @param identifier - The identifier of the schema being validated, used to cache the validator.\n * @returns The result of the validation. If the state is 'error', the errors will be in a zod-like format.\n */\nexport function jsonSchemaValidate(\n  subject: object,\n  schema: SchemaObject,\n  handleInvalidAdditionalProperties: HandleInvalidAdditionalProperties,\n  identifier?: string,\n): ParseConfigurationResult<unknown> & {rawErrors?: AjvError[]} {\n  const subjectToModify = cloneDeep(subject)\n\n  const cacheKey = identifier ?? randomUUID()\n\n  const validator = validatorsCache.get(cacheKey) ?? createAjvValidator(handleInvalidAdditionalProperties, schema)\n  validatorsCache.set(cacheKey, validator)\n\n  validator(subjectToModify)\n\n  // Errors from the contract are post-processed to be more zod-like and to deal with unions better\n  let jsonSchemaErrors\n  if (validator.errors && validator.errors.length > 0) {\n    jsonSchemaErrors = convertJsonSchemaErrors(validator.errors, subjectToModify, schema)\n    return {\n      state: 'error',\n      data: undefined,\n      errors: jsonSchemaErrors,\n      rawErrors: validator.errors,\n    }\n  }\n\n  if (handleInvalidAdditionalProperties === 'strip') {\n    const topLevelSchemaProperties = Object.keys(schema.properties ?? {})\n    // strip any properties that are not in the top level schema from subjectToModify\n    Object.keys(subjectToModify).forEach((key) => {\n      if (!topLevelSchemaProperties.includes(key)) {\n        // this isn't actually dynamic, because key came from Object.keys\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete subjectToModify[key as keyof typeof subjectToModify]\n      }\n    })\n  }\n\n  return {\n    state: 'ok',\n    data: subjectToModify,\n    errors: undefined,\n    rawErrors: undefined,\n  }\n}\n\n/**\n * Converts errors from Ajv into a zod-like format.\n *\n * @param rawErrors - JSON Schema errors taken directly from Ajv.\n * @param subject - The object being validated.\n * @param schema - The JSON schema to validated against.\n * @returns The errors in a zod-like format.\n */\nfunction convertJsonSchemaErrors(rawErrors: AjvError[], subject: object, schema: SchemaObject) {\n  // This reduces the number of errors by simplifying errors coming from different branches of a union\n  const errors = simplifyUnionErrors(rawErrors, subject, schema)\n\n  // Now we can remap errors to be more zod-like\n  return errors.map((error) => {\n    const path: string[] = error.instancePath.split('/').slice(1)\n    if (error.params.missingProperty) {\n      const missingProperty = error.params.missingProperty as string\n      return {path: [...path, missingProperty], message: 'Required'}\n    }\n\n    if (error.params.type) {\n      const expectedType = Array.isArray(error.params.type)\n        ? error.params.type.join(', ')\n        : (error.params.type as string)\n      const actualType = getPathValue(subject, path.join('.'))\n      return {path, message: `Expected ${expectedType}, received ${typeof actualType}`}\n    }\n\n    if (error.keyword === 'anyOf' || error.keyword === 'oneOf') {\n      return {path, message: 'Invalid input'}\n    }\n\n    if (error.params.allowedValues) {\n      const allowedValues = error.params.allowedValues as string[]\n      const actualValue = getPathValue(subject, path.join('.'))\n      return {\n        path,\n        message: `Invalid enum value. Expected ${allowedValues\n          .map((value) => JSON.stringify(value))\n          .join(' | ')}, received ${JSON.stringify(actualValue)}`.replace(/\"/g, \"'\"),\n      }\n    }\n\n    if (error.params.comparison) {\n      const comparison = error.params.comparison as string\n      const limit = error.params.limit\n      const actualValue = getPathValue(subject, path.join('.'))\n\n      let comparisonText = comparison\n      switch (comparison) {\n        case '<=':\n          comparisonText = 'less than or equal to'\n          break\n        case '<':\n          comparisonText = 'less than'\n          break\n        case '>=':\n          comparisonText = 'greater than or equal to'\n          break\n        case '>':\n          comparisonText = 'greater than'\n          break\n      }\n\n      return {\n        path,\n        message: capitalize(`${typeof actualValue} must be ${comparisonText} ${limit}`),\n      }\n    }\n\n    if (error.params.additionalProperty) {\n      const supportedProperties = Object.keys(error.parentSchema?.properties ?? {})\n\n      // if a property was already set, remove it from here\n      const alreadySetProperties = Object.keys(error.data ?? {})\n      const remainingProperties = supportedProperties.filter((property) => !alreadySetProperties.includes(property))\n\n      if (remainingProperties.length > 0) {\n        return {\n          path: [...path, error.params.additionalProperty as string],\n          message: `No additional properties allowed. You can set ${remainingProperties.sort().join(', ')}.`,\n        }\n      }\n    }\n\n    return {\n      path,\n      message: error.message,\n    }\n  })\n}\n\n/**\n * If a JSON schema specifies a union (anyOf, oneOf), and the subject doesn't meet any of the 'candidates' for the\n * union, then the error list received ends up being quite long: you get an error for the union property itself, and\n * then additional errors for each of the candidate branches.\n *\n * This function simplifies the error collection. By default it strips anything other than the union error itself.\n *\n * In some cases, it can be possible to identify what the intended branch of the union was -- for instance, maybe there\n * is a discriminating field like `type` that is unique between the branches. We inspect each candidate branch and if\n * one branch is less wrong than the others -- e.g. It had a valid `type`, but problems elsewhere -- then we keep the\n * errors for that branch.\n *\n * This is complex but in practise gives much more actionable errors.\n *\n * @param rawErrors - JSON Schema errors taken directly from Ajv.\n * @param subject - The object being validated.\n * @param schema - The JSON schema to validated against.\n * @returns A simplified list of errors.\n */\nfunction simplifyUnionErrors(rawErrors: AjvError[], subject: object, schema: SchemaObject): AjvError[] {\n  let errors = rawErrors\n\n  const resolvedUnionErrors = new Set()\n  while (true) {\n    const unionError = errors.filter(\n      (error) =>\n        (error.keyword === 'oneOf' || error.keyword === 'anyOf') && !resolvedUnionErrors.has(error.instancePath),\n    )[0]\n    if (unionError === undefined) {\n      break\n    }\n    // split errors into those sharing an instance path and those not\n    const unrelatedErrors = errors.filter((error) => !error.instancePath.startsWith(unionError.instancePath))\n\n    // we start by assuming only the union error itself is useful, and not the errors from the candidate schemas\n    let simplifiedUnionRelatedErrors: AjvError[] = [unionError]\n\n    // get the schema list from where the union issue occured\n    const dottedSchemaPath = unionError.schemaPath.replace('#/', '').replace(/\\//g, '.')\n    const unionSchemas = getPathValue<SchemaObject[]>(schema, dottedSchemaPath)\n    // and the slice of the subject that caused the issue\n    const subjectValue = getPathValue(subject, unionError.instancePath.split('/').slice(1).join('.'))\n\n    if (unionSchemas !== undefined && subjectValue !== undefined) {\n      // we know that none of the union schemas are correct, but for each of them we can measure how wrong they are\n      const correctValuesAndErrors = unionSchemas\n        .map((candidateSchemaFromUnion: SchemaObject) => {\n          const candidateSchemaValidator = createAjvValidator('fail', candidateSchemaFromUnion)\n          candidateSchemaValidator(subjectValue)\n\n          let score = 0\n          if (candidateSchemaFromUnion.type === 'object') {\n            // provided the schema is an object, we can measure how many properties are good\n            const candidatesObjectProperties = Object.keys(candidateSchemaFromUnion.properties)\n            score = candidatesObjectProperties.reduce((acc, propertyName) => {\n              const subSchema = candidateSchemaFromUnion.properties[propertyName] as SchemaObject\n              const subjectValueSlice = getPathValue(subjectValue, propertyName)\n\n              const subValidator = createAjvValidator('fail', subSchema)\n              if (subValidator(subjectValueSlice)) {\n                return acc + 1\n              }\n              return acc\n            }, score)\n          }\n\n          return [score, candidateSchemaValidator.errors!] as const\n        })\n        .sort(([scoreA], [scoreB]) => scoreA - scoreB)\n\n      if (correctValuesAndErrors.length >= 2) {\n        const [bestScore, bestErrors] = correctValuesAndErrors[correctValuesAndErrors.length - 1]!\n        const [penultimateScore] = correctValuesAndErrors[correctValuesAndErrors.length - 2]!\n\n        if (bestScore !== penultimateScore) {\n          // If there's a winner, show the errors for the best schema as they'll likely be actionable.\n          // We got these through a nested schema, so we need to adjust the instance path\n          simplifiedUnionRelatedErrors = [\n            unionError,\n            ...bestErrors.map((bestError) => ({\n              ...bestError,\n              instancePath: unionError.instancePath + bestError.instancePath,\n            })),\n          ]\n        }\n      }\n    }\n    errors = [...unrelatedErrors, ...simplifiedUnionRelatedErrors]\n\n    resolvedUnionErrors.add(unionError.instancePath)\n  }\n  return errors\n}\n"]}