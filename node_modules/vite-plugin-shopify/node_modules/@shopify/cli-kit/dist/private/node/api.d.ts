import { Headers } from 'form-data';
export type API = 'admin' | 'storefront-renderer' | 'partners' | 'business-platform' | 'app-management';
export declare const allAPIs: API[];
export type NetworkRetryBehaviour = {
    useNetworkLevelRetry: true;
    maxRetryTimeMs: number;
} | {
    useNetworkLevelRetry: false;
};
type RequestOptions<T> = {
    request: () => Promise<T>;
    url: string;
} & NetworkRetryBehaviour;
/**
 * Checks if an error is a transient network error that is likely to recover with retries.
 *
 * Use this function for retry logic. Use isNetworkError for error classification.
 *
 * Examples of transient errors (worth retrying):
 * - Connection timeouts, resets, and aborts
 * - DNS failures (enotfound, getaddrinfo, eai_again) - can be temporary
 * - Socket disconnects and hang ups
 * - Premature connection closes
 */
export declare function isTransientNetworkError(error: unknown): boolean;
/**
 * Checks if an error is any kind of network-related error (connection issues, timeouts, DNS failures,
 * TLS/certificate errors, etc.) rather than an application logic error.
 *
 * These errors should be reported as user-facing errors (AbortError) rather than bugs (BugError),
 * regardless of whether they are transient or permanent.
 *
 * Examples include:
 * - Transient: connection timeouts, socket hang ups, temporary DNS failures
 * - Permanent: certificate validation failures, misconfigured SSL
 */
export declare function isNetworkError(error: unknown): boolean;
export declare function simpleRequestWithDebugLog<T extends {
    headers: Headers;
    status: number;
}>(requestOptions: RequestOptions<T>, errorHandler?: (error: unknown, requestId: string | undefined) => unknown): Promise<T>;
/**
 * Makes a HTTP request to some API, retrying if response headers indicate a retryable error.
 *
 * If a request fails with a 429, the retry-after header determines a delay before an automatic retry is performed.
 *
 * If unauthorizedHandler is provided, then it will be called in the case of a 401 and a retry performed. This allows
 * for a token refresh for instance.
 *
 * If there's a network error, e.g. DNS fails to resolve, then API calls are automatically retried.
 *
 * @param request - A function that returns a promise of the response
 * @param url - The URL to request
 * @param errorHandler - A function that handles errors
 * @param unauthorizedHandler - A function that handles unauthorized errors
 * @param retryOptions - Options for the retry
 * @returns The response from the request
 */
export declare function retryAwareRequest<T extends {
    headers: Headers;
    status: number;
}>(requestOptions: RequestOptions<T>, errorHandler?: (error: unknown, requestId: string | undefined) => unknown, retryOptions?: {
    limitRetriesTo?: number;
    defaultDelayMs?: number;
    scheduleDelay: (fn: () => void, delay: number) => void;
}): Promise<T>;
export {};
